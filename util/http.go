package util

import (
	"bytes"
	"context"
	"crypto"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/pkg/errors"
)

var (
	locationHeaderErr = "get location from header error"
	retryErr          = fmt.Sprintf("retry error for %s times", retryTimes)

	retryTimes = 5
)

// Error is an ACME error, defined in Problem Details for HTTP APIs doc
// http://tools.ietf.org/html/draft-ietf-appsawg-http-problem.
type Error struct {
	// StatusCode is The HTTP status code generated by the origin server.
	StatusCode int
	// ProblemType is a URI reference that identifies the problem type,
	// typically in a "urn:acme:error:xxx" form.
	ProblemType string
	// Detail is a human-readable explanation specific to this occurrence of the problem.
	Detail string
	// Header is the original server error response headers.
	// It may be nil.
	Header http.Header
}

func (e *Error) Error() string {
	return fmt.Sprintf("%d %s: %s", e.StatusCode, e.ProblemType, e.Detail)
}

func DoAcmeGet(ctx context.Context, client *http.Client, url string) (*http.Response, string, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, "", err
	}

	res, err := client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, "", err
	}

	// ACME need update nonce for next invoke
	nonce := res.Header.Get("Replay-Nonce")

	return res, nonce, nil
}

func DoAcmePost(ctx context.Context, client *http.Client, url, contentType string, body io.Reader) (*http.Response, string, error) {
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, "", err
	}

	req.Header.Set("Content-Type", contentType)

	res, err := client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, "", err
	}

	// ACME need update nonce for next invoke
	nonce := res.Header.Get("Replay-Nonce")

	return res, nonce, nil
}

func DoAcmeJwsPost(ctx context.Context, client *http.Client, key crypto.Signer, nonce, kid, url string, body interface{}) (*http.Response, string, error) {
	b, err := JWSPreload(body, key, nonce, kid, url)
	if err != nil {
		return nil, "", err
	}

	res, newNonce, err := DoAcmePost(ctx, client, url, "application/jose+json", bytes.NewReader(b))
	if err != nil {
		return nil, "", err
	}

	return res, newNonce, nil
}

func RetryAcmeJwsPost(ctx context.Context, client *http.Client, key crypto.Signer, nonce, kid, url string, body interface{}, flushNonce func()) (*http.Response, string, error) {
	for i := 0; i < retryTimes; i++ {
		if i > 0 {
			err := Sleep(ctx, 3*1000)
			if err != nil {
				return nil, "", err
			}
		}

		res, newNonce, err := DoAcmeJwsPost(ctx, client, key, nonce, kid, url, body)
		if err != nil {
			return nil, "", err
		}

		if res.StatusCode >= 400 && res.StatusCode <= 599 {
			err := ResponseError(res)
			res.Body.Close()

			if IsBadNonce(err) {
				flushNonce()
				continue
			}
			return nil, "", err
		}
		return res, newNonce, nil
	}

	return nil, "", errors.New(retryErr)
}

func JWSPreload(claimset interface{}, key crypto.Signer, nonce string, kid string, url string) ([]byte, error) {
	algorithm, hasher := JwsHasher(key)
	if algorithm == "" {
		return nil, errors.New("unsupported key type, only (rs256, es256, es384) are supported.")
	}

	protected := ""

	if kid != "" {
		// { "alg": "ES256", "kid": "https://example.com/acme/acct/1", "nonce": "Q_s3MWoqT05TrdkM2MTDcw", "url": "https://example.com/acme/new-account"}
		protected = fmt.Sprintf(`{"alg":%q,"kid":%q,"nonce":%q,"url":%q}`, algorithm, kid, nonce, url)
	} else {
		jwk, err := JwkEncode(key.Public())
		if err != nil {
			return nil, err
		}
		// { "alg": "RS256", "jwk": /* certificate's public key */, "nonce": "JHb54aT_KTXBWQOzGYkt9A", "url": "https://example.com/acme/new-account"}
		protected = fmt.Sprintf(`{"alg":%q,"jwk":%q,"nonce":%q,"url":%q}`, algorithm, jwk, nonce, url)
	}

	protectedBase64 := base64.RawURLEncoding.EncodeToString([]byte(protected))

	payload, err := json.Marshal(claimset)
	if err != nil {
		return nil, err
	}

	payloadBase64 := base64.RawURLEncoding.EncodeToString(payload)

	hash := hasher.New()
	hash.Write([]byte(protectedBase64 + "." + payloadBase64))

	signature, err := JwsSign(key, hasher, hash.Sum(nil))
	if err != nil {
		return nil, err
	}

	encode := struct {
		Protected string `json:"protected"`
		Payload   string `json:"payload"`
		Sig       string `json:"signature"`
	}{
		Protected: protectedBase64,
		Payload:   payloadBase64,
		Sig:       base64.RawURLEncoding.EncodeToString(signature),
	}

	return json.Marshal(&encode)
}

func LocationHeader(res *http.Response) (string, error) {
	location := res.Header.Get("Location")
	if location == "" {
		return "", errors.New(locationHeaderErr)
	}

	return location, nil
}

// LinkHeader returns URI-Reference values of all Link headers
// with relation-type rel.
// See https://tools.ietf.org/html/rfc5988#section-5 for details.
func LinkHeader(h http.Header, rel string) []string {
	var links []string
	for _, v := range h["Link"] {
		parts := strings.Split(v, ";")
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if !strings.HasPrefix(p, "rel=") {
				continue
			}
			if v := strings.Trim(p[4:], `"`); v == rel {
				links = append(links, strings.Trim(parts[0], "<>"))
			}
		}
	}
	return links
}

// IsBadNonce reports whether err is an ACME "badnonce" error.
func IsBadNonce(err error) bool {
	// According to the spec badNonce is urn:ietf:params:acme:error:badNonce.
	// However, ACME servers in the wild return their versions of the error.
	// See https://tools.ietf.org/html/draft-ietf-acme-acme-02#section-5.4
	// and https://github.com/letsencrypt/boulder/blob/0e07eacb/docs/acme-divergences.md#section-66.
	ae, ok := err.(*Error)
	return ok && strings.HasSuffix(strings.ToLower(ae.ProblemType), ":badnonce")
}

// ResponseError creates an error of Error type from resp.
func ResponseError(resp *http.Response) error {
	// don't care if ReadAll returns an error:
	// json.Unmarshal will fail in that case anyway
	b, _ := ioutil.ReadAll(resp.Body)
	e := &WireError{Status: resp.StatusCode}
	if err := json.Unmarshal(b, e); err != nil {
		// this is not a regular error response:
		// populate detail with anything we received,
		// e.Status will already contain HTTP response code value
		e.Detail = string(b)
		if e.Detail == "" {
			e.Detail = resp.Status
		}
	}
	return e.Error(resp.Header)
}

// WireError is a subset of fields of the Problem Details object
// as described in https://tools.ietf.org/html/rfc7807#section-3.1.
type WireError struct {
	Status int
	Type   string
	Detail string
}

func (e *WireError) Error(h http.Header) *Error {
	return &Error{
		StatusCode:  e.Status,
		ProblemType: e.Type,
		Detail:      e.Detail,
		Header:      h,
	}
}

func Sleep(ctx context.Context, ms int) error {
	wakeup := time.NewTimer(time.Duration(ms) * time.Millisecond)
	defer wakeup.Stop()

	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-wakeup.C:
		return nil
	}
}
